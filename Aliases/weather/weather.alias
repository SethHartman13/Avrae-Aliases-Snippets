embed
<drac2>
# *******************************************************
# * This work includes material taken from the System Reference Document 5.1 
# * (“SRD 5.1”) by Wizards of the Coast LLC and available at https://dnd.wizards.com/resources/systems-reference-document. 
# * The SRD 5.1 is licensed under the Creative Commons Attribution 4.0 International License 
# * available at https://creativecommons.org/licenses/by/4.0/legalcode.
# * 
# * This work includes material written by Seth Hartman (aka ShadowsStride)
# * and is licensed under the Creative Commons Attribution 4.0 International License 
# * available at https://creativecommons.org/licenses/by/4.0/legalcode.
# *******************************************************


def search_key(query: str, key_list: list[str]) -> list[str]|str:
    """
    Searches for dictionary key.

    Args:
        query (str): The query being made
        key_list (list): List of keys

    Return:
        (str): If it finds it, it returns the key, otherwise it returns 'None'
    """

    # Creates list to store matches
    results_keys = []

    # For each key in the key_list
    for key in key_list:

        # Sets up process to creater iterations
        initial_iterations = []
        iterations = []
        lst = []
        lst[:] = key.lower()

        for i in range(len(key) + 1):
            initial_iterations.append(lst[:i])


        # So, what happens is it will create iterations like 'r' and 're'
        # This removes the first two so that at least three letters are needed
        initial_iterations.pop(0)
        initial_iterations.pop(0)


        # Puts all the iterations of the key in a list
        for iteration in initial_iterations:
            iterations.append("".join(iteration))

        # If the query returns a match, it will return the key
        if query.lower() in iterations:

            results_keys.append(key)

        else:
            pass

    # If there are matches, return a list
    if len(results_keys) != 0:
        return results_keys

    # If there are no matches, return a string
    else:
        return "None"


def roll_dice(dice_type:str, baseline: int = 0) -> list:
    """
    Rolls dice and puts together string to use.

    Args:
        dice_type (str): What dice to roll
        baseline (int): What to add to the dice roll

    Return:
        (list): List of results

    """
    
    # Rolls dice
    roll_obj = vroll(dice_type)

    # If baseline is 0
    if baseline == 0:
        roll_string = f"{roll_obj.dice} = {roll_obj.total}"
    
    # If baseline is not 0
    else:
        roll_string = f"{roll_obj.dice} + {baseline} = {baseline + roll_obj.total}"

    return [roll_string, baseline + roll_obj.total]


def to_celsius(degrees: int) -> float:
    """
    Converts Fahrenheit to Celsius

    Args:
        degrees (int): Temperature to be converted

    Return:
        (float): Results of the conversion

    """
    return round((degrees - 32) * (5/9), 1)


def get_season(season:str, dict_keys:list[str]) -> list[str]:

    key_result = search_key(season, dict_keys)

    if key_result != 'None':
        if len(key_result) == 0:
            return ['Success', key_result[0]]

        else:
            for key in key_result:
                if season.lower() == key.lower():
                    return ["Success", key]

                else:
                    pass

            return ['Error', f'Season not found!']

    else:
        return ['Error', f'Season not found!']

def get_temperature(temp_dice: str, temp_base: int, location_name: str) -> list[str]:

    try:
        results = roll_dice(temp_dice, temp_base)
        
        if results[1] <= 32:
            freezing = True
        else:
            freezing = False

        return ['Success', f'{results[0]} degrees fahrenheit ({to_celsius(results[1])} degrees celsius)\n' + "", freezing]

    except:
        return ['Error', f'Problems rolling temperature for {location_name}']


def get_water(water_chance_dice: str, water_roll_thresholds: dict, freezing: bool, location_name: str) -> list[str]:

    try: 
        results = roll_dice(water_chance_dice)

        for key in water_roll_thresholds.keys():
            if results[1] >= int(key):
                water_result = water_roll_thresholds[key]
            
            else:
                pass
        lower_water_result = water_result.lower()

        if lower_water_result == "heavy":
            water_rate = randint(5, 20) / 10
            disadv = "Disadvantage on Wisdom (Perception) checks"

        elif lower_water_result == 'heavy fog':
            water_rate = 0
            disadv = "Disadvantage on sight-based Wisdom (Perception) checks"

        elif lower_water_result == 'light':
            water_rate = randint(1, 3) / 10
            disadv = "None"

        else:
            water_rate = 0
            disadv = "None"

        
        if lower_water_result == 'light' or lower_water_result == 'heavy':
            if freezing:
                water_result = f"{results[0]}: `{water_result} Rain`  {water_rate} in/hr ({round(water_rate * 25.4,1)} mm/hr)"

            else:
                water_result = f"{results[0]}: `{water_result} Snow`  {water_rate} in/hr ({round(water_rate * 25.4,1)} mm/hr)"

        else:
            water_result = f"{results[0]}: `{water_result}`"

        if disadv != "None":
            water_result = "\n".join(["**Moisture:**", water_result, f"**{disadv}**", ""])

        else:
            water_result = "\n".join(["**Moisture:**", water_result, ""])

        return ['Success', water_result]

    except:
        return ['Error', f'Problems rolling water for {location_name}']


def get_wind(wind_chance_dice: str, wind_roll_thresholds: dict, location_name: str) -> list[str]:

    try: 
        results = roll_dice(wind_chance_dice)

        for key in wind_roll_thresholds.keys():
            if results[1] >= int(key):
                wind_result = wind_roll_thresholds[key]
            
            else:
                pass
        lower_wind_result = wind_result.lower()

        # Heavy wind, sets wind speed, adds disadvantage note (also converts from mph to km/h)
        if lower_wind_result == "heavy wind":
            wind_rate = randint(25,54)
            wind_result = f"{results[0]}: `{wind_result}`  {wind_rate} mph ({round(wind_rate * 1.60934, 1)} km/h)"
            disadv = "Disadvantage on ranged weapon attacks"

        # Light wind, sets wind speed (also converts from mph to km/h)
        elif lower_wind_result == "light wind":
            wind_rate = randint(8,54)
            wind_result = f"{results[0]}: `{wind_result}`  {wind_rate} mph ({round(wind_rate * 1.60934, 1)} km/h)"
            disadv = "None"

        # Gentle breeze, sets wind speed (also converts from mph to km/h)
        elif lower_wind_result == "gentle breeze":
            wind_rate = randint(1,7)
            wind_result = f"{results[0]}: `{wind_result}`  {wind_rate} mph ({round(wind_rate * 1.60934, 1)} km/h)"
            disadv = "None"

        # No wind
        else:
            wind_result = f"{results[0]}: `{wind_result}`"
            disadv = "None"

        if disadv != "None":
            wind_result = '\n'.join(["**Wind:**", wind_result, f"**{disadv}**", ""])

        else:
            wind_result = '\n'.join(["**Wind:**", wind_result, ""])

        return ["Success", wind_result]

    except:
        return ["Error", f'Problems rolling wind for {location_name}']


def get_weather(season: str) -> list[str]:
    result_list = []

    weather_settings_test = get_svar("weather_location_list", default="None")

    if weather_settings_test != "None":
        weather_settings_dict = load_json(weather_settings_test)
    
    else:
        return ['Error', '`weather_location_list` svar is missing']

    for location in weather_settings_dict.values():
        location_test = get_svar(location, default="None")

        if location_test != "None":
            location_dict = load_json(location_test)

            try:
                result_list.append(f"**{location_dict['name']}**")

            except:
                return ['Error', f'svar `{location}` is missing a name property']

            results = get_season(season, location_dict.keys())

            # Grabs season settings
            if results[0] != 'Error':
                season_settings = location_dict[results[1]]

                # Roll temperature
                results = get_temperature(season_settings['temp_dice'], season_settings['temp_base'], location_dict['name'])
                
            else:
                return results

            # If there are no errors
            if results[0] != "Error":

                # Append temperature to result_list
                result_list.append(results[1])

                # Roll water
                results2 = get_water(season_settings['water_chance_dice'], season_settings['water_roll_thresholds'], results[2], location_dict['name'])

            else:
                return results

            # If there are no errors
            if results2[0] != "Error":

                # Append water to result_list
                result_list.append(results2[1])

                # Roll wind
                results3 = get_wind(season_settings['wind_chance_dice'], season_settings['wind_roll_thresholds'], location_dict['name'])
                

            else:
                return results2

            # If there are no errors
            if results3[0] != "Error":

                # Append wind to result_list
                result_list.append(results3[1])

            else:
                return results3

            result_list.append("")
            
        else:
            return ['Error', f'svar `{location}` does not exist']

    return ['Success', "\n".join(result_list)]


def main(input_list: list[str]) -> list[str]:
    
    if len(input_list) >= 1:
        results = get_weather(input_list[0])

        if results[0] != "Error":
            return [f"The daily weather report by {ctx.author.display_name}", results[1]]

        else:
            return [f"{ctx.author.display_name} encountered an error running the daily weather report", results[1]]

    else:
        return [f"{ctx.author.display_name} encountered an error running the daily weather report", "Expected 1 argument"]


# Calling main function
output = main(&ARGS&)

# Prepares outputs for embed insert
title = output[0]
result_string = output[1]

</drac2>

-title "{{title}}"
-f "{{result_string}}"
-thumb "https://raw.githubusercontent.com/SethHartman13/Avrae-Aliases-Snippets/master/Aliases/weather/image.png"
-footer "!weath [season] | Updated 6/27/2023 | ShadowsStride"