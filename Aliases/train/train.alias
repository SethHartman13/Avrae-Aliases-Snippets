embed
<drac2>
# *******************************************************
# * This work includes material taken from the System Reference Document 5.1 
# * (“SRD 5.1”) by Wizards of the Coast LLC and available at https://dnd.wizards.com/resources/systems-reference-document. 
# * The SRD 5.1 is licensed under the Creative Commons Attribution 4.0 International License 
# * available at https://creativecommons.org/licenses/by/4.0/legalcode.
# * 
# * This work includes material written by Seth Hartman (aka ShadowsStride)
# * and is licensed under the Creative Commons Attribution 4.0 International License 
# * available at https://creativecommons.org/licenses/by/4.0/legalcode.
# *******************************************************


def search_key(query: str, key_list: list[str]) -> list[str]|str:
    """
    Searches for dictionary key.

    Args:
        query (str): The query being made
        key_list (list): List of keys

    Return:
        (str): If it finds it, it returns the key, otherwise it returns 'None'
    """

    # Creates list to store matches
    key_results = []

    # Checks each item if a match occurs
    for key in key_list:

        # If matches
        if query.lower() in key.lower():
            key_results.append(key)

        else:
            pass

    # Finds at least 1 match
    if len(key_results) > 0:
        return key_results

    # If it finds no matches
    else:
        return 'None'


def get_settings_dict() -> dict:
    """
    Grabs/constructs settings dictionary

    Return:
        (dict): Settings dictionary
    """

    def set_default_settings(settings_dict: dict, default_dict: dict) -> dict:
        """
        Sets default parameters when items are missing
        
        Args:
            settings_dict (dict): Dictionary to set default parameters to
            default_dict (dict): Dictionary of default parameters

        Return:
            (dict): Resultant dictionary
        
        """
        # For each item in the default dictionary
        for key, value in default_dict.items():

            # Check to see if there is an entry in the settings dictionary
            try:
                settings_dict[key]

            # Due to missing key, set value to default value
            except:
                settings_dict[key] = value

        return settings_dict

    # Checks to see if the settings_svar exists
    settings_test = get_svar('training_settings')
    default_dict = {'max_val': 10, 'disp_type': 'star', 'jack_of_trades': 1, 'time_cooldown': 561600, 'thresholds': {"-999": 0, "10": 1, "20": 2}}
    
    # If settings dict exists, set missing values to default values
    if settings_test:
        settings_dict = set_default_settings(load_json(settings_test), default_dict)
        
        # Checks to see if -999 threshold exists
        try:
            settings_dict['thresholds']["-999"]

        # If -999 didn't exist        
        except:
            settings_dict['thresholds']["-999"] = 0

        return settings_dict

    # If settings dict does not exist
    else:
        return default_dict


def grab_tool_weapon_lang_skill_armor() -> dict:
    """
    Grabs all the dictionaries necessary for the skills

    Return:
        (dict): Dictionary of all proficencies and relavant skills
    """

    # Default values
    # Tool dictionary
    tool_dict = {
    "alchemist's supplies": ["int", "wis"],
    "brewer's supplies": ["int", "wis", "cha"],
    "calligrapher's supplies": ["dex", "int", "cha"],
    "carpenter's tools": ["str", "dex", "int", "wis"],
    "cobbler's tools": ["str", "dex", "int", "wis", "cha"],
    "cook's tools": ["dex", "int", "wis"],
    "glassblower's tools": ["dex", "int"],
    "jeweler's tools": ["dex", "cha"],
    "leatherworker's tools": ["str", "dex", "wis"],
    "mason's tools": ["str", "int"],
    "painter's supplies": ["dex", "wis", "cha"],
    "potter's tools": ["dex", "wis"],
    "thieves' tools": ["dex", "int"],
    "tinker's tools": ["dex", "int"],
    "weaver's tools": ["dex", "int", "wis"],
    "woodcarver's tools": ["dex", "int", "wis"],
    "disguise kit": ["int", "wis", "cha"],
    "forgery kit": ["int", "wis"],
    "herbalism kit": ["int", "wis"],
    "navigator's tools": ["int", "wis"],
    "poisoner's kit": ["int", "wis"],
    "smith's tools": ["str", "dex"]
    }

    # Language dictionary
    lang_dict = {
    "abanasinian": ["int", "wis", "cha"], 
    "abyssal": ["int", "wis", "cha"], 
    "aquan": ["int", "wis", "cha"], 
    "auran": ["int", "wis", "cha"], 
    "celestial": ["int", "wis", "cha"], 
    "daelkyr": ["int", "wis", "cha"], 
    "deep speech": ["int", "wis", "cha"], 
    "draconic": ["int", "wis", "cha"], 
    "dwarvish": ["int", "wis", "cha"], 
    "elvish": ["int", "wis", "cha"], 
    "ergot": ["int", "wis", "cha"], 
    "giant": ["int", "wis", "cha"], 
    "gith": ["int", "wis", "cha"], 
    "gnomish": ["int", "wis", "cha"], 
    "goblin": ["int", "wis", "cha"], 
    "hadozee": ["int", "wis", "cha"], 
    "halfling": ["int", "wis", "cha"], 
    "ignan": ["int", "wis", "cha"], 
    "infernal": ["int", "wis", "cha"], 
    "istarian": ["int", "wis", "cha"], 
    "kenderspeak": ["int", "wis", "cha"], 
    "kharolian": ["int", "wis", "cha"], 
    "khur": ["int", "wis", "cha"], 
    "kothian": ["int", "wis", "cha"], 
    "kraul": ["int", "wis", "cha"], 
    "leonin": ["int", "wis", "cha"], 
    "loxodon": ["int", "wis", "cha"], 
    "marquesian": ["int", "wis", "cha"], 
    "minotaur": ["int", "wis", "cha"], 
    "naush": ["int", "wis", "cha"], 
    "nerakese": ["int", "wis", "cha"], 
    "nordmaarian": ["int", "wis", "cha"], 
    "ogre": ["int", "wis", "cha"], 
    "orc": ["int", "wis", "cha"], 
    "primordial": ["int", "wis", "cha"], 
    "quori": ["int", "wis", "cha"], 
    "riedran": ["int", "wis", "cha"], 
    "solamnic": ["int", "wis", "cha"], 
    "sylvan": ["int", "wis", "cha"], 
    "terran": ["int", "wis", "cha"], 
    "thri-kreen": ["int", "wis", "cha"], 
    "undercommon": ["int", "wis", "cha"], 
    "vedalken": ["int", "wis", "cha"], 
    "zemnian": ["int", "wis", "cha"]
    }

    # Weapon dictionary
    weapon_dict = {
    "club": ["str"], 
    "dagger": ["str", "dex"], 
    "greatclub": ["str"], 
    "handaxe": ["str"], 
    "javelin": ["str"], 
    "light hammer": ["str"], 
    "mace": ["str"], 
    "quarterstaff": ["str"], 
    "sickle": ["str"], 
    "spear": ["str"], 
    "yklwa": ["str"], 
    "light crossbow": ["dex"], 
    "dart": ["dex"], 
    "shortbow": ["dex"], 
    "sling": ["dex"], 
    "battleaxe": ["str"], 
    "flail": ["str"], 
    "glaive": ["str"], 
    "greataxe": ["str"], 
    "greatsword": ["str"], 
    "halberd": ["str"], 
    "lance": ["str"], 
    "longsword": ["str"], 
    "maul": ["str"], 
    "morningstar": ["str"], 
    "pike": ["str"], 
    "rapier": ["str", "dex"], 
    "scimitar": ["str", "dex"], 
    "shortsword": ["str", "dex"], 
    "trident": ["str"], 
    "war pick": ["str"], 
    "warhammer": ["str"], 
    "whip": ["str", "dex"], 
    "blowgun": ["dex"], 
    "hand crossbow": ["dex"], 
    "heavy crossbow": ["dex"], 
    "longbow": ["dex"], 
    "net": ["str"]
    }

    # Instrument dictionary
    instrument_dict = {
    "bagpipes": ["int", "cha"], 
    "drum": ["int", "cha"], 
    "dulcimer": ["int", "cha"], 
    "flute": ["int", "cha"], 
    "lute": ["dex", "int", "cha"], 
    "horn": ["int", "cha"],
    "pan flute": ["int", "cha"],
    "shawm": ["int", "cha"],
    "lyre": ["dex", "int", "cha"],  
    "viol": ["dex", "int", "cha"],
    "bird pipes": ["int", "cha"],
    "glaur": ["con", "cha"],
    "hand drum": ["dex", "cha"],
    "longhorn": ["wis", "cha"],
    "songhorn": ["int", "cha"],
    "tantan": ["dex", "cha"],
    "thelarr": ["int", "cha"],
    "tocken": ["dex", "cha"],
    "wargong": ["str", "cha"],
    "whistle-stick": ["wis", "cha"],
    "yarting": ["dex", "cha"],
    "zulkoon": ["con", "cha"]
    }

    # Gaming set dictionary
    gaming_dict = {
    "dice set": ["dex", "int", "wis", "cha"], 
    "dragonchess set": ["int", "wis", "cha"], 
    "playing card set": ["dex", "int", "wis", "cha"], 
    "three-dragon ante set": ["int", "wis", "cha"]
    }

    # Setup
    full_dict = dict()
    list_dicts = []

    # Thank you genesisest for putting these dictionaries together
    # Tool dictionary
    tool_test = get_svar('tool_dict')
    if tool_test:
        list_dicts.append(load_json(tool_test))

    else:
        list_dicts.append(tool_dict)

    # Language dictionary
    lang_test = get_svar('lang_dict')
    if lang_test:
        list_dicts.append(load_json(lang_test))
    
    else:
        list_dicts.append(lang_dict)

    # Weapon dictionary
    weapon_test = get_svar('weapon_dict')
    if weapon_test:
        list_dicts.append(load_json(weapon_test))

    else:
        list_dicts.append(weapon_dict)

    # Instrument dictionary
    instrument_test = get_svar('instrument_dict')
    if instrument_test:
        list_dicts.append(load_json(instrument_test))

    else:
        list_dicts.append(instrument_dict)

    # Gaming set dictionary
    game_test = get_svar('gaming_dict')
    if game_test != 'None':
        list_dicts.append(load_json(game_test))

    else:
        list_dicts.append(gaming_dict)

    # Skill dictionary
    skill_test = get_svar('skill_dict')
    if skill_test:
        list_dicts.append(load_json(skill_test))
    else:
        pass

    # Armor dictionary
    armor_test = get_svar('armor_dict')
    if armor_test:
        list_dicts.append(load_json(armor_test))
    else:
        pass

    # Combines all the dictionaries into one
    return {key: value, for dictionary in list_dicts for key, value in dictionary.items()}


def find_highest_stat(stat_list: list, ch = character()) -> int:
    """
    Finds the highest ability mod that is relavant
    
    Args:
        stat_list (list): List of relavant abilities
        ch = character(): Character object

    Return:
        (int): Ability mod
    """

    # Checks to see if there is a subclass cvar
    subclass_test = ch.get_cvar("subclass", default="None")

    # If fey wanderer is not in subclass cvar
    if "fey wanderer" not in subclass_test.lower():
        char_mod = charismaMod

    # If fey wanderer is in subclass cvar
    else:
        char_mod = charismaMod + wisdomMod

    # Creates mod dictionary
    mod_dict = {"str": strengthMod, "dex": dexterityMod, "con": constitutionMod, "wis": wisdomMod, "int": intelligenceMod, "cha": char_mod}

    # For stats not in the stat_list, set them to -999
    for stat in list(set(mod_dict.keys()).symmetric_difference(set(stat_list))):
        mod_dict[stat] = -999

    return [mod_dict[max(mod_dict)], max(mod_dict)]


def setup_training_cc(target: str, settings_dict: dict, ch = character()) -> list[str]:
    """
    Sets up the training CC
    
    Args:
        target (str): Target training name
        settings_dict (dict): Settings dictionary (svar)
        ch = character(): Character object

    Return:
        (list[str]): Result
    """

    full_dict = grab_tool_weapon_lang_skill_armor()
    key_result = search_key(target, full_dict.keys())

    # If it finds at least one proficiency
    if key_result != "None":

        # If it find only one proficiency
        if len(key_result) == 1:
            target = key_result[0]

        # If it finds more than one proficiency
        else:
            for key in key_result:
                if name.lower() == key.lower():
                    
                    target = key
                    
                else:
                    pass
            
            key_result.insert(0, "**Multiple proficiencies found:**")

            return ["Error", "\n".join(key_result)]

    # If it does not find a proficiency
    else:
        return ['Error', 'Proficiency not found!']

    
    desc_dict = {"time": 0, "prof": target}

    # Creates the cc
    ch.create_cc(
        name="Training", 
        minVal="0", 
        maxVal=str(settings_dict['max_val'] - find_highest_stat(full_dict[target]))[0], 
        reset=None, 
        dispType=settings_dict['disp_type'], 
        reset_to="0", 
        title=f"{name}'s training ({target})", 
        desc=dump_json(desc_dict), 
        initial_value=0
        )

    return ['Success']


def run_training_session(settings_dict, ch = character(), adv: int = 0, bonus: str = "None", ignore_time: bool = False) -> list[str]:
    """
    Runs a training session

    settings_dict (dict): Settings dictionary
    ch = character(): Character object
    adv (int): Advantage = 1, normal = 0, disadvantage = -1 (default 0)
    bonus (str): Bonus to roll. (default "None")
    ignore_time (bool): Whether to bypass cooldown (default False)

    Return:
        (list[str]): Result
    """

    counter = ch.cc("Training")

    # Full proficiency dictionary
    full_dict = grab_tool_weapon_lang_skill_armor()

    # Dictionary from description
    desc_dict = load_json(counter.desc)

    # Current time (in epoch)
    current_time = int(round(time(), 0))

    # Grabs appropriate ability mod and name
    result_list = find_highest_stat(full_dict[desc_dict['prof']])

    # If it is run at the appropriate timeframe (or that is ignored)
    if (current_time >= desc_dict['time'] + settings_dict['time_cooldown']) or ignore_time:

        # If no advantage/disadvantage
        if adv == 0:
            dice = "1d20"
        
        # If advantage
        elif adv == 1:
            dice = "2d20kh1"

        # If disadvantage
        else:
            dice = "2d20kl1"

        # Checks for the bard jack of trades
        if settings_dict['jack_of_trades'] == 1:

            for (player_cls, level) in ch.levels:
                if player_cls == "Bard" and level >= 2:
                    if bonus == "None":
                        bonus = floor(proficiencyBonus / 2)

                    else:
                        bonus = f"{bonus} + {floor(proficiencyBonus / 2)}"

                else:
                    pass
        else:
            pass

        # If there is no bonus
        if bonus == "None":
            roll_check = vroll(f"{dice} + {result_list[0]}")

        # If there is no bonus
        else:
            roll_check = vroll(f"{dice} + {bonus} + {result_list[0]}")

        # Figures out how much the counter is increased by
        for key in settings_dict['thresholds'].keys():
            if roll_check.result.total >= int(key):
                mod_num = settings_dict['thresholds'][key]

            else:
                pass

        # Increases counter
        counter.mod(mod_num)

        # If time was not ignored
        if not ignore_time:
            desc_dict['time'] = current_time
            desc_dict['bypass'] = False

        # If time was ignored
        else:
            desc_dict['bypass'] = True

        # Edits the cc
        ch.edit_cc("Training", minVal="0", maxVal=str(settings_dict['max_val'] - result_list[0]), desc=dump_json(desc_dict), dispType=settings_dict['disp_type'])
    
        return ['Success', roll_check, mod_num, result_list[1]]

    # If time was not skipped and time cooldown has not been met
    else:
        return ['Error', f"You have until <t:{desc_dict['time'] + settings_dict['time_cooldown']}:f> before you can train again"]


def threshold_string(threshold_dict: dict) -> str:

    string_list = [f"**DC:** # of successes"]
    
    for key, value in threshold_dict.items():
        string_list.append(f"**{key}:** {value}")

    return "\n".join(threshold_string)


def main(input_list: list[str] = [], ch=character()) -> list[str]:
    """
    Main program function
    
    Args:
        input_list (list[str]): List if inputs (default [])
        ch=character(): Character object

    Return:
        (list[str]): Result
    """

    # If length of inputs is not zero
    if len(input_list) != 0:

        # If the first input is not -b, -i, adv, or dis
        if input_list[0].lower() not in ['-b', '-i', 'adv', 'dis']:

            if ch.cc_exists("Training"):
                return [f'{ctx.author.display_name} has encountered an error', "Training CC already exists"]

            else:
                pass

            # Grabs settings dictionary
            settings_dict = get_settings_dict()

            # Pops train target from input list
            train_target = input_list.pop(0)
            
            # Parses arguments
            args = argparse(" ".join(input_list))
            adv = args.adv()
            bonus = args.last("b", default="None")
            ignore_time = args.last('i', default=False)

            # Sets up the training cc
            results = setup_training_cc(train_target, settings_dict)

            if results[0] != 'Error':
                pass
            
            else:
                return [f'{ctx.author.display_name} has encountered an error', results[1]]

        else:

            # If the training cc doesn't exist
            if not ch.cc_exists("Training"):
                return [f'{ctx.author.display_name} has encountered an error', "Training CC doesn't exist"]

            # If the training cc exists
            else:
                pass

            # Grabs settings dictionary
            settings_dict = get_settings_dict()

            # Parses arguments
            args = argparse(" ".join(input_list))
            adv = args.adv()
            bonus = args.last("b", default="None")
            ignore_time = args.last('i', default=False)

        # Runs training sessions
        results = run_training_session(settings_dict, adv=adv, bonus=bonus, ignore_time=ignore_time)

    else:

        # If training cc doesn't exist
        if not ch.cc_exists("Training"):
            return [f'{ctx.author.display_name} has encountered an error', "Training CC doesn't exist"]

        # If the training cc exists
        else:
            settings_dict = get_settings_dict()

            # Runs training session
            results = run_training_session(settings_dict)

    # if there was no error
    if results[0] != "Error":

        counter = ch.cc('Training')

        # Loads description 
        desc_dict = load_json(counter.desc)

        # Capitalizes proficiency
        prof_name = desc_dict['prof']
        prof_name_list_temp = prof_name.split(" ")
        prof_name_list = []
        for prof_name in prof_name_list_temp:
            prof_name_list.append(prof_name.capitalize())
        prof_name = " ".join(prof_name_list)

        ability_dict = {"str": "Strength", "dex": "Dexterity", "con": "Constitution", "int": "Intelligence", "wis": "Wisdom", "cha": "Charisma"}

        # Results
        result_string = [f"**{ability_dict[results[3]]}**", threshold_string(settings_dict['thresholds'])]
        result_string.append(f"{str(results[1])}")
        result_string.append(ch.cc_str('Training'))
        result_string.append(f"{counter.value}/{counter.max}  (+{results[2]})")
        result_string.append(f"Next training session: <t:{desc_dict['time'] + settings_dict['time_cooldown']}:f>")

        # If the counter is finished
        if counter.value == counter.max:
            result_string.append(f"You have finished your training for {prof_name}! Run `!train clear` and come again next time!")

        else:
            pass

        # If cooldown was bypassed
        if desc_dict['bypass']:
            result_string.append('**`Cooldown timer bypassed`**')
        
        else:
            pass

        return [f'{name} ({ctx.author.display_name}) Training Session: {prof_name}', '\n'.join(result_string)]

    else:
        return [f'{ctx.author.display_name} has encountered an error', results[1]]


output_list = main(&ARGS&)
left_arrow = "<"
dash = "-"


</drac2>
-title "{{output_list[0]}}"
-f "{{output_list[1]}}"
-thumb "https://raw.githubusercontent.com/SethHartman13/Avrae-Aliases-Snippets/master/Aliases/train/image.png"
-footer "!train {{left_arrow}}prof_name> {{left_arrow}}{{dash}}b> {{left_arrow}}adv/dis> | Updated 9/25/2023 | ShadowsStride"